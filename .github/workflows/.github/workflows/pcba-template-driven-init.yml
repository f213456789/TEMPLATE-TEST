name: PCBA Tracking - Init Folder, Links, Sub-Issues (Template Driven)

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  issues: write

jobs:
  init:
    if: contains(github.event.issue.labels.*.name, 'pcb-tracking')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # âœ… needed for rebase/push safety

      # =====================================================
      # 1) Parse Issue Template fields (NO dependency on title)
      #    - Project Code drives everything
      #    - Owner fields must match Issue Template labels exactly
      # =====================================================
      - name: Parse issue template fields
        id: parse
        shell: bash
        run: |
          set -e
          BODY="${{ github.event.issue.body }}"

          get_field () {
            # robust: find the line after "### <label>"
            echo "$BODY" | grep -A1 "### $1" | tail -n1 | xargs || true
          }

          CODE="$(get_field 'Project Code')"

          if ! echo "$CODE" | grep -qE '^VB[0-9]{4}$'; then
            echo "Invalid or missing Project Code: $CODE"
            echo "code=" >> $GITHUB_OUTPUT
            exit 0
          fi

          PREFIX="${CODE:0:4}xx"
          echo "code=$CODE" >> $GITHUB_OUTPUT
          echo "prefix=$PREFIX" >> $GITHUB_OUTPUT

          # MUST match your Issue Template labels EXACTLY:
          echo "gerber=$(get_field 'Gerber æª”æ¡ˆè² è²¬äººï¼ˆGitHub username æˆ– emailï¼‰')" >> $GITHUB_OUTPUT
          echo "owner3d=$(get_field '3D åœ–æª”è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "owner2d=$(get_field '2D åœ–æª”è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "pnp=$(get_field 'Pick & Place è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "sticker=$(get_field 'Sticker / Silk è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "inspection=$(get_field 'Inspection Index è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "dxf=$(get_field 'DXF è“‹æ¿åœ–è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "marking=$(get_field 'Marking / ICDM è² è²¬äºº')" >> $GITHUB_OUTPUT
          echo "grr=$(get_field 'GRR Report è² è²¬äºº')" >> $GITHUB_OUTPUT

      # =====================================================
      # 2) Create folder structure
      # =====================================================
      - name: Create folder structure
        if: steps.parse.outputs.code != ''
        shell: bash
        run: |
          set -e
          CODE="${{ steps.parse.outputs.code }}"
          PREFIX="${{ steps.parse.outputs.prefix }}"
          BASE="Project/${PREFIX}/${CODE}"

          mkdir -p "${BASE}"/{01_Gerber,02_3D,03_2D,04_PnP,05_Sticker_Silk,06_Inspection_Index,07_DXF,08_Marking_ICDM,09_GRR_Report}

          for d in "${BASE}"/*; do
            touch "$d/.gitkeep"
          done

          cat > "${BASE}/README.md" << EOF
          # PCBA Data Package - ${CODE}
          Please upload files to corresponding folders.
          EOF

      # =====================================================
      # 3) Commit & push (safe against "fetch first" conflicts)
      # =====================================================
      - name: Commit & push (safe)
        if: steps.parse.outputs.code != ''
        shell: bash
        run: |
          set -e

          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"

          git add Project/
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "Init PCBA folders for ${{ steps.parse.outputs.code }} (issue #${{ github.event.issue.number }})"

          # âœ… safest: rebase onto latest remote, then push with retries
          for i in 1 2 3; do
            git fetch origin main
            git rebase origin/main || (git rebase --abort && true)

            if git push origin HEAD:main; then
              echo "Push succeeded."
              exit 0
            fi

            echo "Push failed, retry $i..."
            sleep 2
          done

          echo "Push failed after retries."
          exit 1

      # =====================================================
      # 4) Comment checklist with per-folder links (parent issue)
      # =====================================================
      - name: Comment checklist with per-folder links
        if: steps.parse.outputs.code != ''
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const issue_number = context.payload.issue.number;

            const code   = "${{ steps.parse.outputs.code }}";
            const prefix = "${{ steps.parse.outputs.prefix }}";
            const branch = (context.ref || "refs/heads/main").replace("refs/heads/", "");
            const base   = `Project/${prefix}/${code}`;
            const baseUrl = `https://github.com/${owner}/${repo}/tree/${branch}/${base}`;

            const items = [
              { name: "Gerberï¼šå«æ¿å±¤ Gerber æª”", folder: "01_Gerber" },
              { name: "PCBA 3D åœ–æª”ï¼ˆå«å…ƒä»¶æ“ºæ”¾ï¼å«é«˜åº¦ï¼‰", folder: "02_3D" },
              { name: "PCBA 2D å°ºå¯¸åœ–ï¼ˆå«æ¿å¤–å½¢ã€å­”ä½/å°ºå¯¸ç­‰ï¼‰", folder: "03_2D" },
              { name: "Pick & Place / è²¼ç‰‡åº§æ¨™ï¼ˆå«æ—‹è½‰è§’ã€é¢åˆ¥ï¼‰", folder: "04_PnP" },
              { name: "PCBA Sticker / Silkï¼ˆçµ²å°ï¼è²¼ç´™åœ–ï¼‰", folder: "05_Sticker_Silk" },
              { name: "PCBA Inspection Indexï¼šæª¢æ¸¬é …ç›®ï¼ˆAOI/ICT/åŠŸèƒ½æ¸¬ç­‰ï¼‰", folder: "06_Inspection_Index" },
              { name: "PCBA è“‹æ¿åœ–ï¼šDXF æª”", folder: "07_DXF" },
              { name: "PCBA æ–‡å­—å°åˆ·ï¼ˆMarking/Labelï¼‰/ ICDM LISTï¼šå‘½åè¦å‰‡", folder: "08_Marking_ICDM" },
              { name: "GRR Reportï¼šGRR å ±å‘Šï¼ˆå¦‚é©ç”¨ï¼‰", folder: "09_GRR_Report" },
            ];

            const checklistLines = items.map(i => {
              const link = `${baseUrl}/${i.folder}`;
              return `- [ ] ${i.name}  \n  ğŸ“ Folderï¼š${link}`;
            }).join("\n");

            const body = [
              `## å°ˆæ¡ˆè³‡æ–™ä¸Šå‚³æª¢æ ¸ï¼ˆå«æ¯é …è³‡æ–™å¤¾é€£çµï¼‰`,
              ``,
              `- Project Codeï¼š **${code}**`,
              `- Repo ç›®çš„åœ°ï¼š \`${base}/\``,
              `- ä¸Šå‚³ç¸½è¦½ï¼ˆGitHub treeï¼‰ï¼š ${baseUrl}`,
              ``,
              `### âœ… æª¢æ ¸æ¸…å–®ï¼ˆé€é …ä¸Šå‚³åˆ°å°æ‡‰è³‡æ–™å¤¾ï¼‰`,
              checklistLines,
              ``,
              `### è¦å‰‡`,
              `- è«‹å°‡è³‡æ–™ä¾é¡åˆ¥/ç‰ˆæœ¬åˆ†é¡æ•´ç†ï¼ˆå·²æä¾›é è¨­ç›®éŒ„ï¼‰`,
              `- å®Œæˆå¾Œè«‹åœ¨æœ¬ Issue å‹¾é¸å®Œæˆé …ç›®ï¼Œä¸¦é™„ä¸Š PR / Commit / å­ Issue é€£çµï¼ˆå¦‚æœ‰ï¼‰`,
              ``,
              `### è£œå……èªªæ˜`,
              `ï¼ˆè«‹åœ¨æ­¤è£œå……ï¼šç¼ºä»¶åŸå› ã€ç‰ˆæœ¬å·®ç•°ã€PR/Commit é€£çµâ€¦ï¼‰`,
            ].join("\n");

            await github.rest.issues.createComment({ owner, repo, issue_number, body });

      # =====================================================
      # 5) Create sub-issues (safe assign + email fallback + real @)
      #    - If username wrong / not collaborator: still create sub-issue (no fail)
      # =====================================================
      - name: Create sub-issues for each checklist item (safe assign)
        if: steps.parse.outputs.code != ''
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const parent = context.payload.issue;
            const parentNumber = parent.number;

            const clean = s => (s ? String(s).trim() : "");
            const isEmail = s => /@/.test(String(s || ""));

            const code   = "${{ steps.parse.outputs.code }}";
            const prefix = "${{ steps.parse.outputs.prefix }}";
            const branch = (context.ref || "refs/heads/main").replace("refs/heads/", "");
            const baseUrl = `https://github.com/${owner}/${repo}/tree/${branch}/Project/${prefix}/${code}`;

            // Optional: sub-issue label (must exist in repo)
            const childLabels = ["pcb-sub"];

            // From Issue Template parsed values:
            const ownersByFolder = {
              "01_Gerber":           clean("${{ steps.parse.outputs.gerber }}"),
              "02_3D":               clean("${{ steps.parse.outputs.owner3d }}"),
              "03_2D":               clean("${{ steps.parse.outputs.owner2d }}"),
              "04_PnP":              clean("${{ steps.parse.outputs.pnp }}"),
              "05_Sticker_Silk":     clean("${{ steps.parse.outputs.sticker }}"),
              "06_Inspection_Index": clean("${{ steps.parse.outputs.inspection }}"),
              "07_DXF":              clean("${{ steps.parse.outputs.dxf }}"),
              "08_Marking_ICDM":     clean("${{ steps.parse.outputs.marking }}"),
              "09_GRR_Report":       clean("${{ steps.parse.outputs.grr }}"),
            };

            // Fallback assignee if input is email/empty/wrong:
            const fallbackAssignees = (parent.assignees?.length ? parent.assignees.map(a => a.login) : [parent.user.login]);

            const items = [
              { title: "Upload Gerber",           folder: "01_Gerber",           desc: "Gerber æª”æ¡ˆä¸Šå‚³èˆ‡ç‰ˆæœ¬ç¢ºèª" },
              { title: "Upload 3D",               folder: "02_3D",               desc: "3Dï¼ˆå«é«˜åº¦ï¼‰ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload 2D",               folder: "03_2D",               desc: "2D å°ºå¯¸åœ–ï¼ˆå¤–å½¢/å­”ä½/å°ºå¯¸ï¼‰ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload PnP",              folder: "04_PnP",              desc: "Pick&Place åº§æ¨™ï¼ˆè§’åº¦/é¢åˆ¥ï¼‰ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload Sticker/Silk",     folder: "05_Sticker_Silk",     desc: "çµ²å°/è²¼ç´™åœ–ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload Inspection Index", folder: "06_Inspection_Index", desc: "æª¢æ¸¬é …ç›®ï¼ˆAOI/ICT/åŠŸèƒ½æ¸¬ï¼‰ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload DXF",              folder: "07_DXF",              desc: "è“‹æ¿åœ– DXF ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload Marking/ICDM",     folder: "08_Marking_ICDM",     desc: "Marking/Labelã€ICDM å‘½åè¦å‰‡ä¸Šå‚³èˆ‡ç¢ºèª" },
              { title: "Upload GRR Report",       folder: "09_GRR_Report",       desc: "GRR å ±å‘Šï¼ˆå¦‚é©ç”¨ï¼‰ä¸Šå‚³èˆ‡ç¢ºèª" },
            ];

            // Avoid duplicates: check existing titles
            const prefixTitle = `[${code}]`;
            const existing = await github.rest.issues.listForRepo({ owner, repo, state: "all", per_page: 100 });
            const existingTitles = new Set(existing.data.map(i => i.title));

            const created = [];

            for (const it of items) {
              const childTitle = `${prefixTitle} ${it.title}`;
              if (existingTitles.has(childTitle)) continue;

              const folderUrl = `${baseUrl}/${it.folder}`;
              const inputOwner = ownersByFolder[it.folder]; // may be username or email

              const desiredAssignees =
                (inputOwner && !isEmail(inputOwner))
                  ? [inputOwner]
                  : fallbackAssignees;

              let issue;
              let assigned = false;
              let usedAssignees = desiredAssignees;

              // Create sub-issue (try assign; if fails, create without assignees)
              try {
                issue = await github.rest.issues.create({
                  owner,
                  repo,
                  title: childTitle,
                  body: [
                    `### ${it.desc}`,
                    ``,
                    `- å°ˆæ¡ˆï¼š**${code}**`,
                    `- å°æ‡‰è³‡æ–™å¤¾ï¼š ${folderUrl}`,
                    `- æ¯ Issueï¼š #${parentNumber}`,
                    ``,
                    `#### å®Œæˆæ¢ä»¶`,
                    `- [ ] æª”æ¡ˆå·²ä¸Šå‚³åˆ°è³‡æ–™å¤¾`,
                    `- [ ] æª”æ¡ˆå‘½å/ç‰ˆæœ¬ç¢ºèª`,
                    `- [ ] å¦‚æœ‰å·®ç•°ï¼Œè£œå……åŸå› èˆ‡ç›¸é—œ PR/Commit é€£çµ`,
                  ].join("\n"),
                  labels: childLabels,
                  assignees: desiredAssignees,
                });
                assigned = true;
              } catch (e) {
                issue = await github.rest.issues.create({
                  owner,
                  repo,
                  title: childTitle,
                  body: [
                    `### ${it.desc}`,
                    ``,
                    `- å°ˆæ¡ˆï¼š**${code}**`,
                    `- å°æ‡‰è³‡æ–™å¤¾ï¼š ${folderUrl}`,
                    `- æ¯ Issueï¼š #${parentNumber}`,
                    ``,
                    `#### å®Œæˆæ¢ä»¶`,
                    `- [ ] æª”æ¡ˆå·²ä¸Šå‚³åˆ°è³‡æ–™å¤¾`,
                    `- [ ] æª”æ¡ˆå‘½å/ç‰ˆæœ¬ç¢ºèª`,
                    `- [ ] å¦‚æœ‰å·®ç•°ï¼Œè£œå……åŸå› èˆ‡ç›¸é—œ PR/Commit é€£çµ`,
                  ].join("\n"),
                  labels: childLabels,
                });
                assigned = false;
                usedAssignees = [];
              }

              created.push(issue.data.number);

              // Mention policy:
              // - only real @username when (a) assigned succeeded and (b) desired assignee is a username
              let mentionLine = "âš ï¸ ç„¡æ³•è‡ªå‹• @ï¼ˆusername éŒ¯èª¤ / æœªåŠ å…¥ Repo / æˆ–å¡«å¯«ç‚º emailï¼‰";
              if (assigned && desiredAssignees.length === 1 && !isEmail(desiredAssignees[0])) {
                mentionLine = `@${desiredAssignees[0]}`;
              } else if (assigned && inputOwner && isEmail(inputOwner)) {
                mentionLine = `âš ï¸ ä½ å¡«çš„æ˜¯ emailï¼ˆGitHub ç„¡æ³• @emailï¼‰ï¼Œå·²è‡ªå‹•æŒ‡æ´¾ï¼š${fallbackAssignees.map(u => `@${u}`).join(" ")}`;
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issue.data.number,
                body: [
                  mentionLine,
                  ``,
                  `è«‹å”åŠ©å®Œæˆ **${it.desc}**`,
                  ``,
                  `ğŸ“ è³‡æ–™å¤¾ï¼š`,
                  folderUrl,
                  ``,
                  `ğŸ‘¤ ä½ å¡«çš„è² è²¬äººï¼š`,
                  inputOwner || "ï¼ˆæœªå¡«ï¼‰",
                  ``,
                  `âœ… å¯¦éš›æŒ‡æ´¾ï¼š`,
                  usedAssignees.length ? usedAssignees.join(", ") : "ï¼ˆæœªè‡ªå‹•æŒ‡æ´¾ï¼Œè«‹æ‰‹å‹•ä¿®æ­£ assigneeï¼‰",
                  ``,
                  `å®Œæˆå¾Œè«‹ç›´æ¥é—œé–‰æ­¤ Sub-Issueã€‚`
                ].join("\n")
              });
            }

            // Parent issue comment: list created subs
            if (created.length) {
              const lines = created.map(n => `- [ ] #${n}`).join("\n");
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: parentNumber,
                body: [
                  `## å·²è‡ªå‹•å»ºç«‹å­ Issueï¼ˆSubï¼‰`,
                  `è«‹ä¾åºå®Œæˆä¸¦é—œé–‰å­ Issueï¼š`,
                  ``,
                  lines
                ].join("\n")
              });
            }
